
local enums = require("enums")
local state_change = enums.state_change

local table_remove = table.remove
local table_insert = table.insert

local meta
local hook_table
local hook_value
local unhook_internal

---@param source table
---@param source_name string
---@return StateFake
local function initial_hook(source, source_name)
  local core = {
    internal_tables = {},
    fake_to_internal = {},
    changed_tables = {},

    __internal = { -- HACK: i do not like this one bit, but it helps keep things generic
      data = {
        [source_name] = source,
      },
    },
  }
  return hook_table(source, core, source_name)
end

---@param source table
---@param core StateCore
---@param key Any
---@return StateFake @ the table source gets modified to become this return value
function hook_table(source, core, key)
  local internal_data = {}
  local internal = { ---@type StateInternal
    core = core,
    data = internal_data,
    child_tables = {},
    -- lowest_changed_index = nil,
    changes = {},
    change_count = 0,
    fake = source, -- source will become the fake table
  }

  core.internal_tables[internal] = true
  core.fake_to_internal[source] = internal

  -- move data to internal_data
  local k, v = next(source) ---@type Any
  while k do
    local nk, nv = next(source, k) ---@type Any
    source[k] = nil
    internal_data[k] = v
    hook_value(v, core, internal, k)
    k, v = nk, nv
  end
  -- source is now the fake table

  source.__internal = internal
  setmetatable(source, meta)
  return source
end

---@param value Any|StateFake
---@param core StateCore
---@param parent StateInternal
---@param key Any
---@return StateFake|nil @ returns a fake table if value was a table otherwise nil
function hook_value(value, core, parent, key)
  local internal = core.fake_to_internal[value]
  if internal then
    parent.child_tables[key] = value
    return value
  elseif type(value) == "table" then
    if value.__internal then
      -- TODO: probably remove cores entirely
      error("Using the same state in different cores is currently not supported.")
    end
    parent.child_tables[key] = value
    return hook_table(value, core, key) -- tail call
  end
end

---@param fake StateFake
---@param internal StateInternal
function unhook_internal(fake, internal)
  local core = internal.core
  core.internal_tables[internal] = nil
  core.changed_tables[internal] = nil
  local fake_to_internal = core.fake_to_internal
  fake_to_internal[fake] = nil

  setmetatable(fake, nil)
  fake.__internal = nil

  -- move data back
  ---@type Any
  for k, v in next, internal.data do
    fake[k] = v
    local child_internal = fake_to_internal[v]
    if child_internal then
      unhook_internal(v, child_internal) -- also unhook children
      -- TODO: maybe don't unhook children implicitly?
    end
  end
end

---@param fake StateFake
---@return nil
local function unhook_table(fake)
  return unhook_internal(fake, fake.__internal)
end

---@param fake_list StateFake
---@param pos integer
---@return Any @ the removed value
local function remove(fake_list, pos)
  local internal = fake_list.__internal
  do
    local lowest_changed_index = internal.lowest_changed_index
    if not lowest_changed_index or pos < lowest_changed_index then
      internal.lowest_changed_index = pos
    end
  end
  local data = internal.data

  -- add change
  local changes = internal.changes
  local change_count = internal.change_count + 1
  internal.change_count = change_count ---@type integer
  changes[change_count] = {
    type = state_change.removed,
    key = pos,
    old = data[pos], ---@type Any
  }

  local child_tables = internal.child_tables
  for i = pos + 1, #data, 1 do
    local target_i = i - 1
    child_tables[target_i] = child_tables[i]
  end

  return table_remove(data, pos)
end

---@param fake_list StateFake
---@param pos integer
---@param value Any
---@return nil
local function insert(fake_list, pos, value)
  local internal = fake_list.__internal
  do
    local lowest_changed_index = internal.lowest_changed_index
    if not lowest_changed_index or pos < lowest_changed_index then
      internal.lowest_changed_index = pos
    end
  end
  local data = internal.data

  -- add change
  local changes = internal.changes
  local change_count = internal.change_count + 1
  internal.change_count = change_count ---@type integer
  changes[change_count] = {
    type = state_change.inserted,
    key = pos,
    new = value,
  }

  local child_tables = internal.child_tables
  for i = #data, pos, -1 do
    local target_i = i + 1
    child_tables[target_i] = child_tables[i]
  end

  hook_value(value, internal.core, internal, pos)

  return table_insert(data, pos, value)
end

---@param fake StateFake
---@return StateChange[]
---@return integer @ change_count
local function get_changes(fake)
  local internal = fake.__internal
  return internal.changes, internal.change_count
end

meta = {
  __len = function(current)
    return #current.__internal.data
  end,
  __pairs = function(current)
    return next, current.__internal.data, nil
  end,
  ---@param current StateFake
  ---@param key Any
  ---@return Any
  __index = function(current, key) -- can optimize this to use a table as the __index
    -- which would requrie a new metatable for every internal table
    -- might be worth doing, not sure yet
    return current.__internal.data[key]
    -- don't even need to check if it's a table because the internal data is storing tables as fake tables
  end,
  ---@param current StateFake
  ---@param key Any
  ---@param new_value Any
  __newindex = function(current, key, new_value)
    local internal = current.__internal
    local core = internal.core

    local internal_data = internal.data
    local old_value = internal_data[key]
    if new_value ~= old_value then
      if not hook_value(new_value, core, internal, key) then
        local old_internal = core.fake_to_internal[old_value]
        if old_internal then
          internal.child_tables[key] = nil
        end
      end

      core.changed_tables[internal] = true

      local changes = internal.changes
      local change_count = internal.change_count + 1
      internal.change_count = change_count ---@type integer
      changes[change_count] = {
        type = state_change.assigned,
        key = key,
        old = old_value,
        new = new_value, ---@type Any -- if it's a table, it's a fake table
      }
      internal_data[key] = new_value
    end
  end,
}

---@param initial_state table
---@param state_name string @ the name associated with the root of the state/initial_state
---@return StateFake
---@return StateCore
local function create_state(initial_state, state_name)
  local state = initial_state or {}
  initial_hook(state, state_name or "state")
  return state, state.__internal.core
end

---@param state StateFake
local function restore_metatables(state)
  for internal in next, state.__internal.core.internal_tables do
    setmetatable(internal.fake, meta)
  end
end

-- undo the debugger being smart and using pairs, therefore __pairs for debugchildren
-- helps debugging the actual state while working on gui-glue
---@diagnostic disable: no-implicit-any
if __DebugAdapter and script.mod_name == "GuiGlue" then
  local variables = require("__debugadapter__.variables")
  local vdescribe = variables.describe
  local vcreate = variables.create

  function meta.__debugline(current)
    setmetatable(current, nil)
    local lineitem = vdescribe(current)
    setmetatable(current, meta)
    return lineitem
  end

  function meta.__debugchildren(current)
    local children = {}
    local count = 0
    for k, v in next, current do
      count = count + 1
      children[count] = vcreate(vdescribe(k), v)
    end
    return children
  end
end
---@diagnostic enable: no-implicit-any

return {
  create_state = create_state,
  restore_metatables = restore_metatables,
  unhook_table = unhook_table,
  remove = remove,
  insert = insert,
  get_changes = get_changes,
}

-- fix semantics