
---@diagnostic disable: no-implicit-any
---@diagnostic disable: undefined-field

local enums = require("enums")
local gui = require("gui")
local state_util = require("state-util")
local util = require("util")

local classes = {} ---@type table<string, StdGuiClass>

local script_data

local function on_load()
  script_data = global.gui_glue_std
  gui.on_load()
end

local function on_init()
  ---@class gui_glue_std_script_data
  script_data = {
  }
  global.gui_glue_std = script_data
  gui.on_init()
end


---@generic T : table
---@param t? T
---@param target? T
---@return T
local function copy(t, target)
  if not t then return target end
  local result = target or {}
  ---@type Any
  for k, v in pairs(t) do
    result[k] = v
  end
  return result
end


---@type StateController
local function draw(controller)
  local changed_state_lut = controller.changed_state_lut
  for internal in next, changed_state_lut do
    local state = internal.fake
    local callback_insts = internal.callback_insts
    if callback_insts then
      for inst in next, callback_insts do
        local state_name = inst.state_name_map[state]
        local on_state_dispatch = inst.on_state_dispatch
        if on_state_dispatch then
          -- TODO: allow modifications to this state in on_state_dispatch
          -- other states can already be modified and it should work, just not the same exact one
          on_state_dispatch(inst, state, state_name)
        end
      end
    end
    state_util.clear_changes(state)
    changed_state_lut[internal] = nil
  end
end

---register a gui inst to be notified when the given state changes
---@param inst GuiInst
---@param state State
local function register_inst_to_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  if not callback_insts then
    callback_insts = {}
    internal.callback_insts = callback_insts
  end
  callback_insts[inst] = true
end

---deregister a gui inst to no longer be notified when the given state changes
---@param inst GuiInst
---@param state State
local function deregister_inst_from_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  callback_insts[inst] = nil
end



---@param structure GuiStructure
---@param parent_class_name string
---@param core_class_name string
local function register_class(structure, parent_class_name, core_class_name)
  local is_core ---@type boolean
  local structure_is_core ---@type boolean
  local inst_prefab ---@type GuiInst
  local state_names ---@type string[]
  local eval_in_create ---@type table<string, fun(state?: State, ...): Any>
  local dynamic_attribute_lut ---@type table<string, StdAttribute[]>
  local funcs ---@type table<string, function>
  local children ---@type table[]
  local child_structures ---@type GuiStructure[] -- TODO: I think
  local structures ---@type GuiStructure[]
  local deriving_name_lut ---@type table<string, boolean>

  local on_create
  local on_elem_created
  local on_state_dispatch
  local on_destroy

  local class_name = parent_class_name
    and parent_class_name.."-"..structure.class_name
    or structure.class_name
  structure.class_name = nil

  local base_class
  if structure.class then
    base_class = classes[structure.class]
    if not base_class then
      error("REEEE")
    end

    is_core = base_class.is_core
    inst_prefab = copy(base_class.inst_prefab)
    state_names = copy(base_class.state_names)
    eval_in_create = copy(base_class.eval_in_create)
    dynamic_attribute_lut = util.copy(base_class.dynamic_attribute_lut)
    funcs = copy(base_class.funcs)
    children = copy(base_class.children)
    structures = copy(base_class.structures)
    deriving_name_lut = base_class.deriving_name_lut

    on_create = base_class.on_create
    on_elem_created = base_class.on_elem_created
    on_state_dispatch = base_class.on_state_dispatch
    on_destroy = base_class.on_destroy
  else
    inst_prefab = {}
    eval_in_create = {}
    dynamic_attribute_lut = {}
    funcs = {}
  end

  if structure.is_core then
    is_core = structure.is_core
    structure.is_core = nil
    structure_is_core = is_core
    deriving_name_lut = deriving_name_lut or {}
  end
  if structure.states then
    state_names = structure.states
    structure.states = nil
  else
    state_names = state_names or {}
  end
  for _, state_name in next, state_names do
    dynamic_attribute_lut[state_name] = dynamic_attribute_lut[state_name] or {}
  end
  if structure.children then
    child_structures = structure.children
    structure.children = nil
    children = {}
  end
  if structure.structures then
    structures = structure.structures
    structure.structures = nil
  end

  if structure.on_create then
    on_create = structure.on_create
    structure.on_create = nil
  end
  if structure.on_elem_created then
    on_elem_created = structure.on_elem_created
    structure.on_elem_created = nil
  end
  if structure.on_state_dispatch then
    on_state_dispatch = structure.on_state_dispatch
    structure.on_state_dispatch = nil
  end
  if structure.on_destroy then
    on_destroy = structure.on_destroy
    structure.on_destroy = nil
  end

  if is_core then
    deriving_name_lut[class_name] = true
  end

  ---@type GuiClass
  local class = {
    class_name = class_name,
    is_core = is_core,
    deriving_name_lut = deriving_name_lut,
    base_class = base_class and base_class.framework_class or nil,
    structures = structures, -- TODO: how to do this properly
  }
  ---@type StdGuiClass
  local std_class = {
    class_name = class_name,
    is_core = is_core,
    core_class_name = core_class_name,
    base_class = base_class,
    framework_class = class,
    inst_prefab = inst_prefab,
    state_names = state_names,
    eval_in_create = eval_in_create,
    dynamic_attribute_lut = dynamic_attribute_lut,
    funcs = funcs,
    children = children,
    deriving_name_lut = deriving_name_lut,

    on_create = on_create,
    on_elem_created = on_elem_created,
    on_state_dispatch = on_state_dispatch,
    on_destroy = on_destroy,
  }

  for func_name, func in pairs(funcs) do
    class[func_name] = func
  end

  classes[class_name] = std_class

  ---@param dynamic_attribute StdAttribute
  local function add_to_dynamic_lut(dynamic_attribute)
    for _, trigger in next, dynamic_attribute.triggers do
      local state_dynamic_attribute_lut = dynamic_attribute_lut[trigger.state_name]
      local field_name = trigger.field_name
      local dynamic_attributes = state_dynamic_attribute_lut[field_name]
      if not dynamic_attributes then
        dynamic_attributes = {}
        state_dynamic_attribute_lut[field_name] = dynamic_attributes
      end
      dynamic_attributes[#dynamic_attributes+1] = dynamic_attribute
    end
  end

  ---@typelist string, Any
  for attribute_name, value in pairs(structure) do
    local value_type = type(value)
    if value_type == "function" then
      ---@narrow value function
      class[attribute_name] = value
      funcs[attribute_name] = value
    elseif value_type == "table" and value.__std_gui then
      ---@narrow value StdAttribute
      value.attribute_name = attribute_name
      if value.type == enums.std_gui_attribute.static then
        eval_in_create[attribute_name] = value.setter
      elseif value.type == enums.std_gui_attribute.dynamic then
        eval_in_create[attribute_name] = value.setter
        add_to_dynamic_lut(value)
      end
    else
      inst_prefab[attribute_name] = value
    end
  end

  if core_class_name then
    function class.on_pre_create(child, parent)
      while parent do
        if parent.is_core and parent.deriving_name_lut[core_class_name] then
          child.core = parent
          break
        end
        parent = parent.parent
      end
    end
  end

  local data = {}
  function class.create(params)
    local inst = {} ---@type GuiInst
    ---@typelist string, Any
    for attribute_name, value in pairs(inst_prefab) do
      inst[attribute_name] = value -- TODO: deepcopy?
    end

    if on_create then
      on_create(inst, params)
    end

    local state_name_map = {}
    data.state_name_map = state_name_map
    local controller = params.controller ---@type StateController
    data.controller = controller
    local states = params.states
    if states then
      for i, state in next, states do
        local state_name = state_names[i]
        data[state_name] = state
        state_name_map[state] = state_name
        state_util.ensure_hook(state)
        register_inst_to_state(inst, state)
      end
    else
      states = {}
      data.states = states
      if state_names then
        for i, state_name in next, state_names do
          local state = params[state_name] ---@type State
          state_name_map[state] = state_name
          if state then
            state_util.ensure_hook(state)
            state_util.add_controller(state, controller) -- make sure the state has this controller added
          else
            state = state_util.create_state(controller) ---@type State
          end
          data[state_name] = state
          states[i] = state

          register_inst_to_state(inst, state)
        end
      end
    end
    data.states = states

    local unpack = table.unpack
    for attribute_name, setter in pairs(eval_in_create) do
      inst[attribute_name] = setter(unpack(states))
    end

    return inst, data
  end

  if on_elem_created then
    function class:on_elem_created()
      on_elem_created(self)
    end
  end

  function class:on_destroy()
    for _, state in next, self.states do
      deregister_inst_from_state(self, state)
    end
    if on_destroy then
      on_destroy(self)
    end
  end

  function class:on_state_dispatch(state, state_name)
    local changes, change_count = state_util.get_changes(state)
    local state_dynamic_attribute_lut = dynamic_attribute_lut[state_name]
    local unpack = table.unpack
    for i = 1, change_count do
      local change = changes[i]
      if change.type == enums.state_change.assigned then
        local dynamic_attributes = state_dynamic_attribute_lut[change.key]
        if dynamic_attributes then
          local elem = self.elem
          for _, dynamic_attribute in pairs(dynamic_attributes) do
            elem[dynamic_attribute.attribute_name] = dynamic_attribute.setter(unpack(self.states))
          end
        end
      end
    end
    if on_state_dispatch then
      on_state_dispatch(self, state, state_name)
    end
  end

  if children then
    local child = {}
    function class:on_children_created()
      child.controller = self.controller
      ---@type GuiChild
      for _, child_class in pairs(children) do
        child.class = child_class.class_name
        self:add(child)
      end
    end
  end

  function class:draw()
    draw(self.controller)
  end

  gui.register_class(class)

  core_class_name = (structure_is_core and class_name) or core_class_name or class_name
  if child_structures then
    ---@typelist integer, GuiStructure
    for _, child in pairs(child_structures) do
      children[#children+1] = {
        class_name = class_name.."-"..child.class_name, -- HACK
      }
      register_class(child, class_name, core_class_name)
    end
  end
  if structures then
    ---@typelist integer, GuiStructure
    for i, sub_structure in pairs(structures) do
      structures[i] = {
        class_name = class_name.."-"..sub_structure.class_name, -- HACK
      }
      register_class(sub_structure, class_name, core_class_name)
    end
  end
end

return {
  on_load = on_load,
  on_init = on_init,
  draw = draw,
  register_inst_to_state = register_inst_to_state,
  deregister_inst_from_state = deregister_inst_from_state,
  register_class = register_class,

  -- debug
  classes = classes,
}

-- fix semantics