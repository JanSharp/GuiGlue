
---@diagnostic disable: no-implicit-any
---@diagnostic disable: undefined-field

#local function main(DEBUG)
#if preprocessor.args.debug and not DEBUG then return end

local enums = require("__GuiGlue__.enums")
local gui = require("__GuiGlue__.gui")
local state_util = require("__GuiGlue__.state-util")
local util = require("util")

local unpack = table.unpack

local classes = {} ---@type table<string, StdGuiClass>

local changed_state_lut

local function on_load()
  gui.on_load()
  state_util.on_load()
  changed_state_lut = state_util.get_changed_state_lut()
end

local function on_init()
  gui.on_init()
  state_util.on_init()
  changed_state_lut = state_util.get_changed_state_lut()
end


local function draw()
  for state in next, changed_state_lut do
    local callback_insts = state.__internal.callback_insts
    if callback_insts then
      for inst in next, callback_insts do
        local state_name = inst.state_name_map[state]
        local on_state_dispatch = inst.on_state_dispatch
        if on_state_dispatch then
          -- TODO: allow modifications to this state in on_state_dispatch
          -- other states can already be modified and it should work, just not the same exact one
          on_state_dispatch(inst, state, state_name)
        end
      end
    end
    state_util.clear_changes(state)
    changed_state_lut[state] = nil
  end
end

---register a gui inst to be notified when the given state changes
---@param inst GuiInst
---@param state State
local function register_inst_to_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  if not callback_insts then
    callback_insts = {}
    internal.callback_insts = callback_insts
  end
  callback_insts[inst] = true
end

---deregister a gui inst to no longer be notified when the given state changes
---@param inst GuiInst
---@param state State
local function deregister_inst_from_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  callback_insts[inst] = nil
end



-- these comments describe how the different things behave
-- when a class derives from another

-- overridden
local special_event_names = {
  "on_elem_created",
  "on_children_created",
  "on_destroy",

  "on_state_dispatch",
  "on_derive", -- TODO: not sure about on_derivee and it's implementation if any
}

local special_field_names = {
  "class_name", -- ignored
  "base_class", -- ignored
  "states", -- merged
  "add_param", -- merged
  "elem_mods", -- merged
  "style_mods", -- merged
  "get_children", -- overridden
  "structures", -- ignored
  "events", -- merged
}
-- any additional data is also merged

local do_not_inherit_field_name_lut = {
  states = true,
  structures = true,
}

local special_field_name_lut = {}
for _, special_func in next, special_event_names do
  special_field_name_lut[special_func] = true
end
for _, special_field in next, special_field_names do
  special_field_name_lut[special_field] = true
end

---@param structure StdGuiStructure
---@param parent_class_name string
local function register_class(structure, parent_class_name)

  structure.add_param = structure.elem
  structure.elem = nil

#if DEBUG then
  print(structure.class_name)
#end

  local structure_class_name_map ---@type table<string, string>

  local static_add_param = {} ---@type table<string, StdAttribute>
  local static_elem_mods = {} ---@type table<string, StdAttribute>
  local static_style_mods = {} ---@type table<string, StdAttribute>

  local dynamic_add_param = {} ---@type table<string, StdAttribute>
  local dynamic_elem_mods = {} ---@type table<string, StdAttribute>
  local dynamic_style_mods = {} ---@type table<string, StdAttribute>

  -- support StdAttributes
  local add_param ---@type LuaGuiElement.add_param
  local elem_mods ---@type ElemOrStyleMods
  local style_mods ---@type ElemOrStyleMods

  -- don't support StdAttributes
  local events
  local extra_class_data = {}

  local class_name = parent_class_name
    and parent_class_name.."-"..structure.class_name
    or structure.class_name
  structure.class_name = class_name

  local base_class
  if structure.base_class then
    base_class = classes[structure.base_class]
    if not base_class then
      error("Unable to find `base_class` '"..base_class.."'.")
    end

    local base_structure = base_class.structure

    ---@param base? table @ from `base_class`
    ---@param this? table @ from `structure`
    ---@return table?
    local function merge(base, this)
      local result = util.copy(base)
      if this then
        result = result or {}
        for k, v in next, this do
          result[k] = v
        end
      end
      return result
    end

    for _, field_name in next, {
      "states",
      "add_param",
      "elem_mods",
      "style_mods",
      "events",
    } do
      structure[field_name] = merge(base_structure[field_name], structure[field_name])
    end

    for _, special_event_name in next, special_event_names do
      if not structure[special_event_name] then
        structure[special_event_name] = base_structure[special_event_name]
      end
    end
    if not structure.get_children then
      structure.get_children = base_structure.get_children
    end

    for field_name, value in next, base_class.extra_class_data do
      if not structure[field_name] then
        structure[field_name] = util.copy(value)
      end
    end

    for k, v in next, base_structure do
      if type(k) == "string" and type(v) == "function" then
        structure["base_"..k] = v
      end
    end

    if base_structure.events and structure.events then
      for k, v in next, base_structure.events do
        structure.events["base_"..k] = v
      end
    end

    structure_class_name_map = util.copy(base_class.structure_names)
  else
    structure_class_name_map = {}
  end

  local state_names = structure.states

  local class = new GuiClass{
    class_name = class_name,
    base_class = base_class and base_class.framework_class or nil,
    structures = structure_class_name_map,
  }
  local std_class = new StdGuiClass{
    class_name = class_name,
    structure = structure,
    base_class = base_class,
    framework_class = class,

    -- needed when inheriting
    state_names = state_names,
    structure_names = structure_class_name_map,
    extra_class_data = extra_class_data,
  }

  classes[class_name] = std_class

  local function parse_table_with_std_attributes(definition, static, dynamic)
    for k, v in next, definition do
      if type(v) == "table" and v.__std_gui then
        ---@narrow v StdAttribute
        if v.type == enums.std_gui_attribute.static then
          static[k] = v
        elseif v.type == enums.std_gui_attribute.dynamic then
          dynamic[k] = v
        end
      end
    end
  end

  add_param = structure.add_param
  if add_param then
    parse_table_with_std_attributes(add_param, static_add_param, dynamic_add_param)
  end

  elem_mods = structure.elem_mods
  if elem_mods then
    parse_table_with_std_attributes(elem_mods, static_elem_mods, dynamic_elem_mods)
  end

  style_mods = structure.style_mods
  if style_mods then
    parse_table_with_std_attributes(style_mods, static_style_mods, dynamic_style_mods)
  end


  events = structure.events
  if events then
    for name, handler in next, events do
      class[name] = handler
    end
  end


  ---@typelist string, Any
  for field_name, value in next, structure do
    if not special_field_name_lut[field_name] then
      extra_class_data[field_name] = value
      class[field_name] = value
    end
  end

  class.on_elem_created = structure.on_elem_created
  class.get_children = structure.get_children

  ---@narrow class StdGuiInst

  local data = {}
  function class.create(params)
    ---@type GuiInstDefinition
    local inst = {
      add_param = add_param,
      elem_mods = elem_mods,
      style_mods = style_mods,
    }

    if state_names then
      local state_name_map = {}
      data.state_name_map = state_name_map
      local states = {}
      data.states = states
      for i, state_name in next, state_names do
        local state = params[state_name] ---@type State
        if state then -- TODO: consider changing the way states are created and passed around
          -- so that if a state is passed in this function call is not needed
          state_util.ensure_hook(state)
        else
          -- TODO: possibly add state initializer functions
          state = state_util.create_state() ---@type State
        end
        state_name_map[state] = state_name
        data[state_name] = state
        states[i] = state

        register_inst_to_state(inst, state)
      end
      data.states = states

      -- TODO: improve performance
      local function run(...)
        #local function eval_attributes(attributes, target, ...)
          for k, attribute in next, $(attributes) do
            $(target)[k] = attribute.setter(...)
          end
        #end

        #eval_attributes("static_add_param", "add_param")
        #eval_attributes("dynamic_add_param", "add_param")
        #eval_attributes("static_elem_mods", "elem_mods")
        #eval_attributes("dynamic_elem_mods", "elem_mods")
        #eval_attributes("static_style_mods", "style_mods")
        #eval_attributes("dynamic_style_mods", "style_mods")
      end
      run(unpack(states))
    end

    return inst, data
  end

  local on_destroy = structure.on_destroy
  function class:on_destroy()
    for _, state in next, self.states do
      deregister_inst_from_state(self, state)
    end
    if on_destroy then
      on_destroy(self)
    end
  end

  ---@type table<string, table<string, StdRuntimeAttribute[]>>
  ---table<state_name, table<field_name, StdRuntimeAttribute[]>>
  local runtime_attribute_map_map = {}
  for _, state_name in next, state_names do
    runtime_attribute_map_map[state_name] = {}
  end
  -- i hate every bit of this but tbh it makes it less of a pain overall
  local function add_or_create(t, k, v)
    local sub_t = t[k]
    if not sub_t then
      sub_t = {n = 0}
      t[k] = sub_t
    end
    local n = sub_t.n + 1
    sub_t.n = n
    sub_t[n] = v
  end
  local function add_to_runtime_attribute_map_map(attributes, is_for_styles)
    for k, attribute in next, attributes do
      for _, trigger in next, attribute.triggers do
        add_or_create(runtime_attribute_map_map[trigger.state_name], trigger.field_name, {
          attribute_name = k,
          setter = attribute.setter,
          is_for_styles = is_for_styles,
        })
      end
    end
  end
  add_to_runtime_attribute_map_map(dynamic_add_param, false)
  add_to_runtime_attribute_map_map(dynamic_elem_mods, false)
  add_to_runtime_attribute_map_map(dynamic_style_mods, true)

  local on_state_dispatch = structure.on_state_dispatch
  local get_changes = state_util.get_changes
  local enums_state_change_assigned = enums.state_change.assigned
  local needs_update = {} ---@type StdRuntimeAttribute[]
  local needs_update_count = 0
  function class:on_state_dispatch(state, state_name)
    local changes, change_count = get_changes(state)
    local runtime_attribute_map = runtime_attribute_map_map[state_name]
    for i = 1, change_count do
      local change = changes[i]
      if change.type == enums_state_change_assigned then
        local runtime_attributes = runtime_attribute_map[change.key]
        if runtime_attributes then
          for j = 1, runtime_attributes.n do
            needs_update_count = needs_update_count + 1
            needs_update[needs_update_count] = runtime_attributes[j]
          end
        end
      end
    end
    if needs_update_count > 0 then
      local elem = self.elem
      local style = elem.style ---@diagnostic disable-line: unused-local
      local function run(...)
        for i = 1, needs_update_count do
          local runtime_attribute = needs_update[i]

          #local function dynamic_set(target, ...)
            #if DEBUG then
              local value = runtime_attribute.setter(...)
              local success, err = pcall(() => {$(target)[runtime_attribute.attribute_name] = value})
              if not success then
                local info = debug.getinfo(runtime_attribute.setter, "S")
                error(info.short_src..":"..info.linedefined..": setter for `$(target)."
                  ..runtime_attribute.attribute_name.."`: "..err)
              end
            #else
              $(target)[runtime_attribute.attribute_name] = runtime_attribute.setter(...)
            #end
          #end

          if runtime_attribute.is_for_styles then
            #dynamic_set("style")
          else
            #dynamic_set("elem")
          end

        end
      end
      run(unpack(self.states))
      needs_update_count = 0
    end
    if on_state_dispatch then
      on_state_dispatch(self, state, state_name)
    end
  end

  local get_children = structure.get_children
  local on_children_created = structure.on_children_created
  if get_children or on_children_created then
    function class:on_children_created()
      if get_children then
        for _, child in next, get_children(self) do
          self:add(child)
        end
      end
      if on_children_created then
        on_children_created(self)
      end
    end
  end

  -- this causes generation of base_foo functions for all of
  -- these functions whenever a class derives from this class
  for _, special_event_name in next, special_event_names do
    if not structure[special_event_name] then
      structure[special_event_name] = () => {}
    end
  end
  if not get_children then
    structure.get_children = () => ({}) -- either this returns an empty table
    -- or in on_children_created when adding children it has to check if the
    -- return value from get_children is nil
    -- because when inheriting a class that didn't define it's own get_children
    -- this would be used, and as you can see, it would also be used by
    -- on_children_created if the deriving class doesn't override it
  end

  gui.register_class(class)

  if structure.structures then
    for structure_name, sub_structure in next, structure.structures do
      register_class(sub_structure, class_name)
      structure_class_name_map[structure_name] = sub_structure.class_name
    end
  end
  structure.structures = nil
end

return {
  on_load = on_load,
  on_init = on_init,
  draw = draw,
  register_inst_to_state = register_inst_to_state,
  deregister_inst_from_state = deregister_inst_from_state,
  register_class = register_class,

  ##if debug then
    classes = classes,
  ##end
}

#end

if settings.startup["GuiGlue-debug"].value then
  #main(true)
else
  #main(false)
end

-- fix semantics