
---@diagnostic disable: no-implicit-any
---@diagnostic disable: undefined-field

local enums = require("enums")
local gui = require("gui")
local state_util = require("state-util")
local util = require("util")

local unpack = table.unpack

local classes = {} ---@type table<string, StdGuiClass>

local script_data

local function on_load()
  script_data = global.gui_glue_std
  gui.on_load()
end

local function on_init()
  ---@class gui_glue_std_script_data
  script_data = {
  }
  global.gui_glue_std = script_data
  gui.on_init()
end


---@generic T : table
---@param t? T
---@param target? T
---@return T
local function copy(t, target)
  if not t then return target end
  local result = target or {}
  ---@type Any
  for k, v in pairs(t) do
    result[k] = v
  end
  return result
end

---@generic T : table
---@param t? T
---@param target? T
---@return T
local function append(t, target)
  if not t then return target end
  local result = target or {}
  ---@type Any
  for _, v in pairs(t) do
    result[#result+1] = v
  end
  return result
end


---@type StateController
local function draw(controller)
  local changed_state_lut = controller.changed_state_lut
  for internal in next, changed_state_lut do
    local state = internal.fake
    local callback_insts = internal.callback_insts
    if callback_insts then
      for inst in next, callback_insts do
        local state_name = inst.state_name_map[state]
        local on_state_dispatch = inst.on_state_dispatch
        if on_state_dispatch then
          -- TODO: allow modifications to this state in on_state_dispatch
          -- other states can already be modified and it should work, just not the same exact one
          on_state_dispatch(inst, state, state_name)
        end
      end
    end
    state_util.clear_changes(state)
    changed_state_lut[internal] = nil
  end
end

---register a gui inst to be notified when the given state changes
---@param inst GuiInst
---@param state State
local function register_inst_to_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  if not callback_insts then
    callback_insts = {}
    internal.callback_insts = callback_insts
  end
  callback_insts[inst] = true
end

---deregister a gui inst to no longer be notified when the given state changes
---@param inst GuiInst
---@param state State
local function deregister_inst_from_state(inst, state)
  local internal = state.__internal
  local callback_insts = internal.callback_insts
  callback_insts[inst] = nil
end



local special_function_names = {
  "on_create",
  "on_elem_created",
  "on_children_created",
  "on_destroy",

  "on_state_dispatch",
  "on_derive",
}

local special_field_names = {
  "base_class",
  "is_core",
  "states",
  "children",
  "structures",
}

local do_not_inherit_field_name_lut = {
  states = true,
  structures = true,
  children = true,
}

local special_field_name_lut = {}
for _, special_func in next, special_function_names do
  special_field_name_lut[special_func] = true
end
for _, special_field in next, special_field_names do
  special_field_name_lut[special_field] = true
end

---@param structure GuiStructure
---@param parent_class_name string
---@param core_class_name string
local function register_class(structure, parent_class_name, core_class_name)

  ---@generic T
  ---@param value? T
  ---@return T?
  local function try_get(value)
    if type(value) == "table" then
      ---@narrow value StdAttribute|table
      if value.__std_gui and value.type == enums.std_gui_attribute.overridden_nil then
        return nil
      end
    end
    return value
  end

  local structure_is_core = try_get(structure.is_core) -- before inheritance
  local deriving_name_lut ---@type table<string, boolean>
  local eval_in_create = {} ---@type table<string, fun(state?: State, ...): Any>
  local child_class_names = {} ---@type string[]
  local structure_class_name_map = {} ---@type table<string, string>

  local inst_prefab = {} ---@type GuiInst

  local class_name = parent_class_name
    and parent_class_name.."-"..structure.class_name
    or structure.class_name
  structure.class_name = class_name

  local base_class
  if structure.base_class then
    base_class = classes[structure.base_class]
    structure.base_class = nil
    if not base_class then
      error("REEEE")
    end

    for k, v in next, base_class.structure do
      if not (structure[k] or do_not_inherit_field_name_lut[k]) then
        structure[k] = util.copy(v)
      end
    end

    if base_class.state_names then
      local states = copy(base_class.state_names)
      if structure.states then
        append(structure.states, states)
      end
      structure.states = states
    end

    if try_get(structure.is_core) then
      deriving_name_lut = base_class.deriving_name_lut
    end

    copy(base_class.child_class_names, child_class_names)
    copy(base_class.structure_names, structure_class_name_map)
  end

  local is_core = try_get(structure.is_core)
  if is_core then
    deriving_name_lut = deriving_name_lut or {}
    deriving_name_lut[class_name] = true
  end

  local state_names = structure.states
  local dynamic_attribute_lut = {} ---@type table<string, StdAttribute[]>
  if state_names then
    for _, state_name in next, state_names do
      dynamic_attribute_lut[state_name] = {}
    end
  end

  ---@type GuiClass
  local class = {
    class_name = class_name,
    is_core = is_core,
    base_class = base_class and base_class.framework_class or nil,
    structures = structure_class_name_map,
    deriving_name_lut = deriving_name_lut,
  }
  ---@type StdGuiClass
  local std_class = {
    class_name = class_name,
    structure = structure,
    base_class = base_class,
    framework_class = class,

    -- needed when inheriting
    state_names = state_names,
    deriving_name_lut = deriving_name_lut,
    child_class_names = child_class_names,
    structure_names = structure_class_name_map,
  }

  classes[class_name] = std_class

  ---@param dynamic_attribute StdAttribute
  local function add_to_dynamic_lut(dynamic_attribute)
    for _, trigger in next, dynamic_attribute.triggers do
      local state_dynamic_attribute_lut = dynamic_attribute_lut[trigger.state_name]
      local field_name = trigger.field_name
      local dynamic_attributes = state_dynamic_attribute_lut[field_name]
      if not dynamic_attributes then
        dynamic_attributes = {}
        state_dynamic_attribute_lut[field_name] = dynamic_attributes
      end
      dynamic_attributes[#dynamic_attributes+1] = dynamic_attribute
    end
  end

  ---@typelist string, Any
  for field_name, value in next, structure do
    if not special_field_name_lut[field_name] then
      local value_type = type(value)
      if value_type == "function" then
        ---@narrow value function
        class[field_name] = value
      elseif value_type == "table" and value.__std_gui then
        ---@narrow value StdAttribute
        value.attribute_name = field_name
        if value.type == enums.std_gui_attribute.static then
          eval_in_create[field_name] = value.setter
        elseif value.type == enums.std_gui_attribute.dynamic then
          eval_in_create[field_name] = value.setter
          add_to_dynamic_lut(value)
        elseif value.type == enums.std_gui_attribute.overridden_nil then
          structure[field_name] = nil
        end
      else
        inst_prefab[field_name] = value
      end
    end
  end

  class.on_elem_created = structure.on_elem_created
  class.on_children_created = structure.on_children_created

  if core_class_name then
    function class.on_pre_create(child, parent)
      while parent do
        if parent.is_core and parent.deriving_name_lut[core_class_name] then
          child.core = parent
          break
        end
        parent = parent.parent
      end
    end
  end

  local on_create = structure.on_create
  local data = {}
  function class.create(params)
    local inst = {} ---@type GuiInst
    ---@typelist string, Any
    for attribute_name, value in next, inst_prefab do
      inst[attribute_name] = value -- TODO: deepcopy?
    end

    if on_create then
      on_create(inst, params)
    end

    local state_name_map = {}
    data.state_name_map = state_name_map
    local controller = params.controller ---@type StateController
    data.controller = controller
    local states = params.states
    if states then
      for i, state in next, states do
        local state_name = state_names[i]
        data[state_name] = state
        state_name_map[state] = state_name
        state_util.ensure_hook(state)
        register_inst_to_state(inst, state)
      end
    else
      states = {}
      data.states = states
      if state_names then
        for i, state_name in next, state_names do
          local state = params[state_name] ---@type State
          state_name_map[state] = state_name
          if state then
            state_util.ensure_hook(state)
            state_util.add_controller(state, controller) -- make sure the state has this controller added
          else
            state = state_util.create_state(controller) ---@type State
          end
          data[state_name] = state
          states[i] = state

          register_inst_to_state(inst, state)
        end
      end
    end
    data.states = states

    for attribute_name, setter in pairs(eval_in_create) do
      inst[attribute_name] = setter(unpack(states))
    end

    return inst, data
  end

  local on_destroy = structure.on_destroy
  function class:on_destroy()
    for _, state in next, self.states do
      deregister_inst_from_state(self, state)
    end
    if on_destroy then
      on_destroy(self)
    end
  end

  local on_state_dispatch = structure.on_state_dispatch
  function class:on_state_dispatch(state, state_name)
    local changes, change_count = state_util.get_changes(state)
    local state_dynamic_attribute_lut = dynamic_attribute_lut[state_name]
    for i = 1, change_count do
      local change = changes[i]
      if change.type == enums.state_change.assigned then
        local dynamic_attributes = state_dynamic_attribute_lut[change.key]
        if dynamic_attributes then
          local elem = self.elem
          for _, dynamic_attribute in pairs(dynamic_attributes) do
            elem[dynamic_attribute.attribute_name] = dynamic_attribute.setter(unpack(self.states))
          end
        end
      end
    end
    if on_state_dispatch then
      on_state_dispatch(self, state, state_name)
    end
  end

  function class:draw()
    draw(self.controller)
  end

  core_class_name = (structure_is_core and class_name) or core_class_name or class_name
  if structure.children then
    local len = #child_class_names
    ---@typelist integer, GuiStructure
    for i, child in next, structure.children do
      register_class(child, class_name, core_class_name)
      child_class_names[len + i] = child.class_name
    end
  end
  structure.children = nil

  if child_class_names[1] then
    local child = {}
    function class:on_children_created()
      child.controller = self.controller
      for _, child_class_name in next, child_class_names do
        child.class = child_class_name
        self:add(child)
      end
    end
  end

  gui.register_class(class)

  if structure.structures then
    ---@typelist string, GuiStructure
    for structure_name, sub_structure in next, structure.structures do
      register_class(sub_structure, class_name, core_class_name)
      structure_class_name_map[structure_name] = sub_structure.class_name
    end
  end
  structure.structures = nil
end

return {
  on_load = on_load,
  on_init = on_init,
  draw = draw,
  register_inst_to_state = register_inst_to_state,
  deregister_inst_from_state = deregister_inst_from_state,
  register_class = register_class,

  -- debug
  classes = classes,
}

-- fix semantics